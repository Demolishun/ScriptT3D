/*
//-----------------------------------------------------------------------------
// pyT3D
// Copyright Demolishun Consulting 2011
//-----------------------------------------------------------------------------
*/
/* File: pyT3D.i */

%module pyT3D

%{
#define SWIG_FILE_WITH_INIT
#include "pyT3D.h"
%}

// convert types
%typemap(in) S32,U32 {
    if (!PyInt_Check($input)) {
      PyErr_SetString(PyExc_TypeError, "Need an integer!");
      return NULL;
	}
	
	$1 = PyInt_AsLong($input);
}
//%typemap(in) U32 = S32;
%typemap(out) S32,U32 {
    $result = PyInt_FromLong($1);
}
//%typemap(out) U32 = S32;

%typecheck(SWIG_TYPECHECK_INTEGER)
	S32,U32
{
	$1 = (PyInt_Check($input) || PyLong_Check($input)) ? 1 : 0;
}


// Grab a Python function object as a Python object.
%typemap(python,in) PyObject *pyfunc {
  if (!PyCallable_Check($input)) {
      PyErr_SetString(PyExc_TypeError, "Need a callable object!");
      return NULL;
  }
  $1 = $input;
}

// Type mapping for grabbing a FILE * from Python
%typemap(python,in) FILE * {
  if (!PyFile_Check($input)) {
      PyErr_SetString(PyExc_TypeError, "Need a file!");
      return NULL;
  }
  $1 = PyFile_AsFile($input);
}

// This tells SWIG to treat char ** as a special case
%typemap(in) char ** {
  /* Check if is a list */
  if (PyList_Check($input)) {
    int size = PyList_Size($input);
    int i = 0;
    $1 = (char **) malloc((size+1)*sizeof(char *));
    for (i = 0; i < size; i++) {
      PyObject *o = PyList_GetItem($input,i);
      if (PyString_Check(o))
	$1[i] = PyString_AsString(PyList_GetItem($input,i));
      else {
	PyErr_SetString(PyExc_TypeError,"list must contain strings");
	free($1);
	return NULL;
      }
    }
    $1[i] = 0;
  } else {
    PyErr_SetString(PyExc_TypeError,"not a list");
    return NULL;
  }
}

// This cleans up the char ** array we malloc'd before the function call
%typemap(freearg) char ** {
  free((char *) $1);
}

%rename("%(strip:[torque_engine])s") "";
// engine startup/shutdown
int torque_engineinit(S32 argc, const char **argv);
//void torque_enginesignalshutdown();

// engine loop
int torque_enginetick();

// engine state/events
int torque_engineshutdown();
%rename("%(strip:[torque_])s") "";
//void torque_reset();

// util
bool torque_isdebugbuild();
//%nothreadallow;
//const char* torque_getexecutablepath();
//%clearnothreadallow;
//void torque_setexecutablepath(const char* directory);
//void torque_resizewindow(S32 width, S32 height);
//void torque_setwebdeployment(); 

// console
//const char* torque_evaluate(const char* code);
//const char* torque_getvariable(const char* name);
//void torque_setvariable(const char* name, const char* value);
//void torque_exportstringcallback(StringCallback cb, const char *nameSpace, const char *funcName, const char* usage,  S32 minArgs, S32 maxArgs);
//const char * torque_callscriptfunction(const char* nameSpace, const char* name, S32 argc, const char ** argv);
//const char* torque_callsecurefunction(const char* nameSpace, const char* name, S32 argc, const char ** argv);
//void torque_addsecurefunction(const char* nameSpace, const char* fname);
%rename("%(strip:[script_])s") "";
//const char * script_getconsolexml();

%rename("MSWIN_%(strip:[torque_])s") "";
// platform specific
//void* torque_gethwnd();
//void torque_directmessage(U32 message, U32 wparam, U32 lparam);

// vars
%rename("%(strip:[torque_])s") "";
//const char* torque_getvariable(const char* name);
//void torque_setvariable(const char* name, const char* value);

// callbacks
%{
// util function 
#define PyPRINTOBJ(obj) PyString_AsString(PyObject_Repr(obj))

// typedef to support callback object
typedef void (*ScriptCBObjectFunction)(void *function, int numparameters, void *parameters);
// callback object for keeping track of scripting language callbacks and data
class ScriptCBObject
{
	public:
		enum CBType
		{
			PythonCallback = 0,
		};	
	private:
		CBType callbacktype;
		void *function;
		// store parameters for use by callback function
		int numparameters;
		void *parameters;
		// a function defined by the scripting language to cleanup stored objects
		ScriptCBObjectFunction cleanupObjects;
	public:
		ScriptCBObject(CBType cbtype, void *func, int numparams=0, void *params=NULL, ScriptCBObjectFunction cfunc=NULL){
			callbacktype = cbtype;
			function = func;
			numparameters = numparams;
			parameters = params;
			cleanupObjects = cfunc;
		}
		~ScriptCBObject(){
			if(cleanupObjects)
				(cleanupObjects)(function,numparameters,parameters);
		}
		CBType getType(){return callbacktype;};
		void* getFunction(){return function;};
		int getNumParameters(){return numparameters;};
		void* getParameters(){return parameters;};
};
// cleanup stored python objects
void pyScriptCBObjectFunction(void *function, int numparameters, void *parameters){
	// protect the GIL
	PyGILState_STATE gstate;
	gstate = PyGILState_Ensure();
	
	Py_XDECREF((PyObject *)function);
	Py_XDECREF((PyObject *)parameters);
	
	// protect the GIL
	PyGILState_Release(gstate);
}

// torque callback, handles console call
//static const char * pyScriptCallback(SimObject *obj, S32 argc, const char **argv){
static const char * pyScriptCallback(SimObject *obj, Namespace *nsObj, S32 argc, const char **argv){
	// protect the GIL
	PyGILState_STATE gstate;
	gstate = PyGILState_Ensure();

	PyObject *pyobj, *tmpfunc, *tuple;
	ScriptCBObject *tmpSBObject;
	struct MarshalNativeEntry *nEntry = NULL;
	
	// buffer for temp strings
	char tempStr[512];
	const char *retstr = "";
	
	// external namespace?
	//bool extNS = false;
	
	//Con::printf("number of arguments: %d",argc);
	//Con::printf("pyScriptCallback: %s::%s", CurrentNSEntry->mNamespace->mName, CurrentNSEntry->mFunctionName);
	
	if(obj){
		//Con::printf("Function called against object: %s::%s",obj->getName(), argv[0]);
		nEntry = script_get_namespace_entry(obj->getName(), argv[0]);
		if(!nEntry)
			Con::printf("Could not find %s::%s in lookup.", obj->getName(), argv[0]);
	}
	if(!nEntry && nsObj->mName != NULL){
		//Con::printf("pyScriptCallback: %s::%s", nsObj->Entry->mNamespace->mName, argv[0]);
		nEntry = script_get_namespace_entry(nsObj->mName, argv[0]);
	}
	if(!nEntry){
		//Con::printf("Function called in global namespace: %s", argv[0]);
		nEntry = script_get_namespace_entry(NULL, argv[0]);
		if(!nEntry)
			Con::printf("Could not find %s in lookup.", argv[0]);
	}
	if(!nEntry){
		//Con::errorf("pyScriptCallback cannot determine namespace for this function and cannot find it in global namespace.");
		PyGILState_Release(gstate);
		return "";
	}
	
	if(!gScriptCallbackLookup.find(nEntry->entry, (void *&)(tmpSBObject))){
		Con::errorf("pyScriptCallback found the function but cannot find the corresponding Python callback.");
		PyGILState_Release(gstate);
		return "";
	}
	if(!tmpSBObject){
		Con::errorf("pyScriptCallback a null script object was returned from lookup.");
		PyGILState_Release(gstate);
		return "";
	}
	
	// create parameter list
	tuple = PyTuple_New(argc-1);
	if(!tuple){
		Con::errorf("pyScriptCallback error allocating memory while creating PyTuple.");
		PyGILState_Release(gstate);
		return "";
	}
	int tupleIndex=0;
	// if there is a simobject then pass as first argument
	if(obj){
		// convert simobject to python object
		pyobj = SWIG_NewPointerObj(SWIG_as_voidptr(obj), SWIGTYPE_p_SimObject, 0 |  0 );
		// PyTuple_SetItem steals the ref so it needs to be incremented
		Py_INCREF(pyobj);
		PyTuple_SetItem(tuple, tupleIndex++, pyobj);
	}
	// populate arguments
	for(int count=1; count<argc; count++){
		PyObject *tref = PyString_FromString(argv[count]);
		if(!tref){
			Con::errorf("pyScriptCallback error allocating memory while creating PyTuple entry.");
			Py_DECREF(tuple);				
			PyGILState_Release(gstate);
			return "";
		}
		PyTuple_SetItem(tuple, tupleIndex++, tref);
	}
	
	// call function
	PyObject *result = NULL;
	tmpfunc = (PyObject *)tmpSBObject->getFunction();
	result = PyEval_CallObject(tmpfunc, tuple);
	Py_DECREF(tuple);
	if (result == NULL){
		//pvalue contains error message
		//ptraceback contains stack snapshot and many other information
		//(see python traceback structure)
		PyObject *ptype, *pvalue, *ptraceback;
		PyErr_Fetch(&ptype, &pvalue, &ptraceback);

		//Get error message
		char *pStrErrorMessage = PyString_AsString(pvalue);
		Con::errorf("pyScriptCallback: %s",pStrErrorMessage);
		PyErr_Clear();
	}else{
		// get results
		const char *tmpstr = NULL;
		if(result != Py_None){
			PyObject *resconv = PyObject_Str(result);
			retstr = Con::getReturnBuffer(PyString_AsString(resconv));
		}
	}
	
	// release refs
	Py_XDECREF(result);
	
	// protect the GIL
	PyGILState_Release(gstate);
	
	return retstr;
}

// storage for function object pointers
static PyObject * ExportCallback(PyObject *self, PyObject *pyargs){
	PyObject *result;
	PyObject *pyfunc, *tmpfunc;
	const char *name;
	const char *usage;
	U32 minargs, maxargs;
	const char *ns = NULL;
	bool override = false;
	
	// buffer for temp strings
	char tempStr[512];

	// parse args and bail if args are wrong
	if (!PyArg_ParseTuple(pyargs, "OssII|zb", &pyfunc, &name, &usage, &minargs, &maxargs, &ns, &override))
        return NULL;
        
    // check for empty namespace strings
    if(ns && !dStrlen(ns))
		ns = NULL;

	// check first arg is python function or bail if not
	if (!PyCallable_Check(pyfunc)){
		dSprintf(tempStr, 512, "First arg must be a valid function. %s does not appear to be a function.",PyPRINTOBJ(pyfunc));
        PyErr_SetString(PyExc_TypeError, tempStr);
        return NULL;
    }
    
    // check for proper console namespace and function names
    if(ns)
		if(!isValidIdentifier(ns)){
			dSprintf(tempStr, 512, "Invalid function namespace identifier: %s",ns);
			PyErr_SetString(PyExc_ValueError, tempStr);
			return NULL;
		}
	if(!isValidIdentifier(name)){
		dSprintf(tempStr, 512, "Invalid function name identifier: %s",name);
		PyErr_SetString(PyExc_ValueError, tempStr);
		return NULL;
	}
	
	// determine if console function exists already if it does bail with exception
	// GetEntry will return non NULL if a function exists either in ns::name() or name() forms
	struct MarshalNativeEntry *nEntry = NULL;
	if(!override)
		if(nEntry = script_get_namespace_entry(ns, name)) {
			dSprintf(tempStr, 512, "%s::%s function was previously exported or was defined in Torque script",nEntry->nameSpace,nEntry->name);
			PyErr_SetString(PyExc_ValueError, tempStr);
			return NULL;
		}
			
	// register function	
	if (!ns)  //(!ns || !dStrlen(ns))
	{
		Con::printf("exporting function: %s", name);
		//script_export_callback_string(pyScriptCallback, ns, name, usage,  minargs, maxargs);
		Con::addScriptCommand(ns, name, pyScriptCallback, usage,  minargs+1, maxargs+1);
	}
	else{
		Con::printf("exporting function: %s::%s", ns, name);
		// must provide an object as first parameter so increase args by 1
		//script_export_callback_string(pyScriptCallback, ns, name, usage,  minargs+1, maxargs+1);
		Con::addScriptCommand(ns, name, pyScriptCallback, usage,  minargs+2, maxargs+2);
	}
		
	// add to callback lookup table
	nEntry = script_get_namespace_entry(ns, name);	
	ScriptCBObject *tempcbobj = NULL;
	if(gScriptCallbackLookup.find(nEntry->entry, (void *&)(tempcbobj))){
		//Con::printf("found previous entry");
		//Py_XDECREF(tmpfunc);
	}
	ScriptCBObject *newcbobj = new ScriptCBObject(ScriptCBObject::PythonCallback, (void *)pyfunc, 0, NULL, pyScriptCBObjectFunction);
	if(!newcbobj){
		dSprintf(tempStr, 512, "%s::%s function registraction failed to allocate memory for ScriptCBObject.",nEntry->nameSpace,nEntry->name);
		PyErr_SetString(PyExc_MemoryError, tempStr);
		return NULL;
	}	
	gScriptCallbackLookup.insertEqual(nEntry->entry,(void*)(newcbobj));
	// if we got an old callback object delete it, cleanup function will do work of cleaning up objects
	if(tempcbobj)
		delete tempcbobj;
	
	// increment ref count for python function object
	Py_XINCREF(pyfunc);
	
	/* Boilerplate to return "None" */
    Py_INCREF(Py_None);
    result = Py_None;
    return result;
}
%}

%native(ExportCallback) static PyObject * ExportCallback(PyObject *self, PyObject *pyargs);

%pythoncode %{
def BuildExecString(objName,name,*args):
	targs = ""
	amax = len(args)
	for i in range(amax):
		arg = args[i]
		targs += '"'+str(arg)+'"'
		if(i < amax-1):
			targs += ","
	if objName is not None:
		fcall = "return "+objName+"."+name+"("+targs+");"
	else:
		fcall = "return "+name+"("+targs+");"
		
	return fcall
%}

class SimObject {
	%pythoncode %{
	def __str__(self):
		return "SimObject: console/simObject.h"
	%}	
};

%rename("Sim") "SimObjs";
class SimObjs {
public:
	static SimObject * FindObject(S32 param);
	static SimObject * FindObject(const char *param);
	static const char* GetVariable(const char *name);
	static bool SetVariable(const char* name, const char* value);
	static bool IsFunction(const char *nameSpace, const char *name);
	static const char* Evaluate(const char* code);
	
	%pythoncode %{
	def __setattr__(self, attribute, value):
		try:
			defattrib = object.__getattribute__(self, attribute)
		except AttributeError,e:
			try:
				defattrib = _swig_getattr(self, Sim, attribute)
			except AttributeError,e:
				setattr = Sim.SetVariable(attribute, value)
				if setattr:
					return
		
		print attribute,repr(value)
	
		setattr = True
		try:
			object.__setattr__(self, attribute, value)
		except AttributeError,e:
			try:
				_swig_setattr(self, Sim, attribute, value)
			except AttributeError,e:
				setattr = False
		if setattr:
			return
			
		raise AttributeError(attribute)
	
	def __getattribute__(self, attribute):
		#print "Attribute:",attribute
		try:
			defattrib = object.__getattribute__(self, attribute)
		except AttributeError,e:
			try:
				defattrib = _swig_getattr(self, Sim, attribute)
			except AttributeError,e:
				#print e
				defattrib = None
		if defattrib is not None:
			return defattrib
			
		# not found in previous definitions
		#print "Looking for attribute:",attribute
		
		# find attribute in console if possible
		sobj = Sim.FindObject(attribute)
		if sobj is not None:
			return sobj
		svar = Sim.GetVariable(attribute)
		if len(svar):
			return svar
		
		fname = [attribute]
		if len(fname) == 1:
			fbool = Sim.IsFunction(None,fname[0])
			if fbool:
				def tfunc(*args):
					#print "function call:",fname[0]
					fcall = BuildExecString(None,fname[0],*args)
					ret = Sim.Evaluate(fcall)
					return ret	
				return tfunc
		elif len(fname) == 2:
			fbool = Sim.IsFunction(fname[0],fname[1])
			if fbool:
				def tfunc(*args):
					#print "function call:",fname[0]+"."+fname[1]
					fcall = BuildExecString(fname[0],fname[1],*args)
					ret = Sim.Evaluate(fcall)
					return ret	
				return tfunc
				
		# if an attribute cannot be found
		raise AttributeError(attribute)

	def __str__(self):
		return "Sim interface for console methods."
	%}	
};