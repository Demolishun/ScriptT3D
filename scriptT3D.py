# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.4
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.



from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_scriptT3D', [dirname(__file__)])
        except ImportError:
            import _scriptT3D
            return _scriptT3D
        if fp is not None:
            try:
                _mod = imp.load_module('_scriptT3D', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _scriptT3D = swig_import_helper()
    del swig_import_helper
else:
    import _scriptT3D
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


swig_RestrictedAttributes = ["this","thisown"]

def BuildExecString(objName,splitval,name,*args):
	targs = ""
	amax = len(args)
	for i in range(amax):
		arg = args[i]
		targs += '"'+str(arg)+'"'
		if(i < amax-1):
			targs += ","
	if objName is not None:
		fcall = "return "+objName+splitval+name+"("+targs+");"
	else:
		fcall = "return "+name+"("+targs+");"
		
	return fcall
	
# stores object and attribute used to retrieve data in this string object
# object and attribute is used in array semantics to further get more data
class AttributeObject(str):	
	def __new__(cls, value, data):
		nobj = str.__new__(cls, value)
		nobj.data = data
		return nobj
	
	# array semantics
	def __setitem__(self, key, value):
		self.data[0].SetAttribute(self.data[1],str(value),str(key))	
	def __getitem__(self, key):
		val = self.data[0].GetAttribute(self.data[1],str(key))
		return val

class SimObject(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SimObject, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SimObject, name)
    __repr__ = _swig_repr
    def __str__(self):
    	return self.getID()
    def __repr__(self):
    	# this returns a string of an object script in TS
    	return self.GetScript()
    	
    # redefine for accessing attributes and methods
    # save original function
    __setattr_org__ = __setattr__
    def __setattr__(self, attribute, value):
    	if attribute in swig_RestrictedAttributes:
    		self.__setattr_org__(attribute, value)
    		return
    		
    	#print attribute
    	# explicit conversion
    	value = str(value)
    				
    	self.SetAttribute(attribute, value)
    	if self.GetAttribute(attribute) != value:
    		raise AttributeError(attribute, "Failed to set attribute to: "+value)
    	
    # save original function
    __getattr_org__ = __getattr__
    def __getattr__(self, attribute):
    	if attribute in swig_RestrictedAttributes:
    		return self.__getattr_org__(attribute)
    	
    	if self.IsMethod(attribute):
    		def tfunc(*args):
    			targs = [attribute,""]
    			for arg in args:
    				targs.append(str(arg))
    			ret = self.CallMethod(len(targs),targs)
    			return AttributeObject(ret,(self,attribute))
    		return tfunc
    	else:			
    		ret = self.GetAttribute(attribute)
    		# there is no way to tell if this failed or succeeded
    		#if ret is None:
    		#	raise AttributeError(attribute, "Failed to get attribute value.")
    		return AttributeObject(ret, (self,attribute))

    def IsAttribute(self, *args): return _scriptT3D.SimObject_IsAttribute(self, *args)
    def IsMethod(self, *args): return _scriptT3D.SimObject_IsMethod(self, *args)
    def GetAttribute(self, *args): return _scriptT3D.SimObject_GetAttribute(self, *args)
    def SetAttribute(self, *args): return _scriptT3D.SimObject_SetAttribute(self, *args)
    def CallMethod(self, *args): return _scriptT3D.SimObject_CallMethod(self, *args)
    def GetScript(self): return _scriptT3D.SimObject_GetScript(self)
    def __init__(self): 
        this = _scriptT3D.new_SimObject()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _scriptT3D.delete_SimObject
    __del__ = lambda self : None;
SimObject_swigregister = _scriptT3D.SimObject_swigregister
SimObject_swigregister(SimObject)
ExportCallback = _scriptT3D.ExportCallback
ExportObject = _scriptT3D.ExportObject
ExportConsumer = _scriptT3D.ExportConsumer

class Sim(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Sim, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Sim, name)
    __repr__ = _swig_repr
    def FindObject(self, *args): return _scriptT3D.Sim_FindObject(self, *args)
    def GetVariable(self, *args): return _scriptT3D.Sim_GetVariable(self, *args)
    def SetVariable(self, *args): return _scriptT3D.Sim_SetVariable(self, *args)
    def IsFunction(self, *args): return _scriptT3D.Sim_IsFunction(self, *args)
    def Evaluate(self, *args): return _scriptT3D.Sim_Evaluate(self, *args)
    def Execute(self, *args): return _scriptT3D.Sim_Execute(self, *args)
    def ExecuteFailed(self): return _scriptT3D.Sim_ExecuteFailed(self)
    # redefine for accessing Sim based objects, variables and functions
    # save original function
    __setattr_org__ = __setattr__
    def __setattr__(self, attribute, value):
    	if attribute in swig_RestrictedAttributes:
    		self.__setattr_org__(attribute, value)
    		return
    	try:
    		self.__setitem__(attribute, value)
    		return
    	except KeyError,e:
    		raise AttributeError(attribute)
    # save original function
    __getattr_org__ = __getattr__
    def __getattr__(self, attribute):
    	if attribute in swig_RestrictedAttributes:
    		return self.__getattr_org__(attribute)
    	try:
    		return self.__getitem__(attribute)
    	except KeyError,e:
    		raise AttributeError(attribute)
    	
    # dictionary style access to Sim based objects, variables and functions
    def __setitem__(self, key, value):		
    	setattr = self.SetVariable(key, value)
    	if setattr:
    		return
    		
    	raise KeyError(key,"is not a valid console variable.")

    def __getitem__(self, key):
    	key = str(key)
    	
    	# find attribute in console if possible
    	sobj = self.FindObject(key)
    	if sobj is not None:
    		return sobj
    	svar = self.GetVariable(key)
    	if len(svar):
    		return svar
    	
    	splitval = None
    	if "::" in key:
    		fname = key.split("::")
    		splitval = "::"
    	elif "." in key:
    		fname = key.split(".")
    		splitval = "."
    	else:
    		fname = [key]
    	if len(fname) == 1:
    		fbool = self.IsFunction(None,fname[0])
    		if fbool:
    			def tfunc(*args):
    				#print "function call:",fname[0]
    				#fcall = BuildExecString(None,None,fname[0],*args)
    				#ret = self.Evaluate(fcall)
    				targs = [fname[0]]
    				for arg in args:
    					targs.append(str(arg))
    				ret = self.Execute(None,len(targs),targs)
    				return ret	
    			return tfunc
    	elif len(fname) == 2:
    		fbool = self.IsFunction(fname[0],fname[1])
    		if fbool:
    			#print "function call:",fname[0]+splitval+fname[1]
    			if splitval == "::":
    				def tfunc(*args):
    					fcall = BuildExecString(fname[0],splitval,fname[1],*args)
    					#print "BuildExecString",fcall
    					ret = self.Evaluate(fcall)
    					return ret
    				return tfunc
    			else:
    				def tfunc(*args):
    					targs = [fname[1],""]
    					for arg in args:
    						targs.append(str(arg))
    					ret = self.Execute(fname[0],len(targs),targs)
    					if self.ExecuteFailed():
    						raise KeyError(key,"not a valid SimObject in function call.")
    					return ret
    				return tfunc
    			
    	# if an attribute cannot be found
    	raise KeyError(key,"is not a valid console variable.")

    def __str__(self):
    	return "Sim interface for console methods."


    def __init__(self): 
        this = _scriptT3D.new_Sim()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _scriptT3D.delete_Sim
    __del__ = lambda self : None;
Sim_swigregister = _scriptT3D.Sim_swigregister
Sim_swigregister(Sim)


def init(*args):
  return _scriptT3D.init(*args)
init = _scriptT3D.init

def tick():
  return _scriptT3D.tick()
tick = _scriptT3D.tick

def shutdown():
  return _scriptT3D.shutdown()
shutdown = _scriptT3D.shutdown

def isdebugbuild():
  return _scriptT3D.isdebugbuild()
isdebugbuild = _scriptT3D.isdebugbuild

def gethwnd():
  return _scriptT3D.gethwnd()
gethwnd = _scriptT3D.gethwnd
# This file is compatible with both classic and new-style classes.


